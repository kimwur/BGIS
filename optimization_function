##### FUNCTION
# optimization of selection based on costs and budget
# budget is input directly here
# costs are in the dataframes.txt file and are easy to change
# this runs based on the feasibility_script already being run 

# how to run: 
# OPTIMIZATION(cell_array, 0.5, 10**5)
# where 'cell_array' is an array of cell ID numbers: [0, 1, 2, 3, 10]
# where wQ represents the weighting of priority towards improving retention capacity over temperature cooling 
#  0 = do not consider Q at all, and only consider T 
#  1 = only consider T, and do not consider T at all

# result:
# will return an array of which BGI (corresponding to order of bgi labels in dataframes.txt) should be selected at each cell
# a result of -1 indicates no BGI is to be installed 


def OPTIMIZATION(cell_array, wQ, budget):
    wT = 1 - wQ
    feasibility_matrix = FEASIBILITY(cell_array)
    n_cell_array = len(cell_array)
    cell_areas = [land_data_dict.get(cell, {}).get('area', 0) for cell in cell_array]
    
    model = LpProblem("BGI_Selection", LpMaximize)
    x = {(c, b): LpVariable(f"x_{c}_{b}", cat="Binary") for c in range(n_cell_array) for b in range(nbgi)}

    # constraint: feasibility
    for c in range(n_cell_array):
        for b in range(nbgi):
            if feasibility_matrix[c][b] == 0:
                model += x[c, b] == 0

    # constraint: max 1 BGI
    for c in range(n_cell_array):
        model += lpSum(x[c, b] for b in range(nbgi)) <= 1

    # constraint: budget
    all_costs = np.array([[capex_arr[b] * cell_areas[c] for b in range(nbgi)] for c in range(n_cell_array)])
    model += lpSum(x[c, b] * all_costs[c, b] for c in range(n_cell_array) for b in range(nbgi)) <= budget
    
    # objective function using weighted MFI 
    wMFI_Q = np.array([[wQ * minmax_Q[b] * cell_areas[c] for b in range(nbgi)] for c in range(n_cell_array)])
    wMFI_T = np.array([[wT * minmax_T[b] * cell_areas[c] for b in range(nbgi)] for c in range(n_cell_array)])
    
    model += lpSum(x[c, b] * (wMFI_Q[c, b] + wMFI_T[c, b]) for b in range(nbgi) for c in range(n_cell_array))
    model.solve(PULP_CBC_CMD(msg=True, timeLimit=30, keepFiles=True))

    selected_bgis = np.zeros(n_cell_array) - 1  # Default -1 (no BGI selected)
    for c in range(n_cell_array):
        for b in range(nbgi):
            if x[c, b].varValue == 1:
                selected_bgis[c] = b  # Store selected BGI

    print(f"Solver Status: {model.status}")
    return selected_bgis
