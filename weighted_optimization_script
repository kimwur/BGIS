##### packages to import 
!pip install pulp
import geopandas as gpd
import pyogrio
import pandas as pd
import ast
import numpy as np
from pulp import LpProblem, LpMaximize, LpVariable, lpSum, LpBinary, LpStatus
import time

%run bgi_catalog.ipynb

import ast
import pandas as pd
import geopandas as gpd

def safe_literal_eval(val):
    if isinstance(val, str):
        try:
            return ast.literal_eval(val)
        except (ValueError, SyntaxError):
            return val
    return val

def apply_safe_literal_eval(df, columns=None):
    df_copy = df.copy()
    
    if columns is None:
        # Select object columns (usually strings)
        columns = df_copy.select_dtypes(include='object').columns.tolist()
    
    for col in columns:
        df_copy[col] = df_copy[col].apply(safe_literal_eval)
    
    return df_copy

def load_bgi_database(filename):
    local_vars = {}
    with open(filename) as f:
        exec(f.read(), {}, local_vars)
    return local_vars

# load information needed and convert different classes within a category (ex LULC) to a matching dictionary
##### packages to import 
import geopandas as gpd
import pyogrio
import pandas as pd
import ast

%run bgi_catalog.ipynb
%run simple_impact.ipynb

##### for reading text per word instead of as string 
def safe_literal_eval(val):
    if isinstance(val, str):
        try:
            return ast.literal_eval(val)
        except Exception:
            return val
    return val

def load_bgi_database(filename):
    local_vars = {}
    with open(filename) as f:
        exec(f.read(), {}, local_vars)
    return local_vars

# loading in the shapefile 
# ENTER YOUR SHAPEFILE HERE
GPKG_FILE='feasibility_results.gpkg'
layers = pyogrio.list_layers(GPKG_FILE)
LAYER_NAME = 'feasibility'
gdf = gpd.read_file(GPKG_FILE, layer=LAYER_NAME, engine='pyogrio')
gdf = apply_safe_literal_eval(gdf)

print(layers)
print(gdf.head())

######################                                DEFINING MULTI-FUNCTIONAL INDEX 
# pre-calculating median BGI performance
retention_arr = np.array([b.get('retention', 0) or 0 for b in bgi_simple_impact.values()])
median_retention = np.median(retention_arr[retention_arr>0])

cooling_arr = np.array([b.get('cooling', 0) or 0 for b in bgi_simple_impact.values()])
median_cooling = np.median(cooling_arr[cooling_arr>0])

# normalize variables
variables = {}
for idx, bgi in area_cap:
    bgi_norm = bgi.lower().replace(' ', '_')
    var_name = f"x_{idx}_{bgi_norm}"
    variables[(idx, bgi_norm)] = LpVariable(var_name, cat='Binary')

######################                                        CALCULATING USEABLE AREA
# this is the maximumm application area PER BGI. it is defined in the BGI database
bgi_max_area = {
    bgi_name: bgi_catalog[bgi_name]['area_m2'].get('max', float('inf')) or float('inf')
    for bgi_name in bgi_simple_impact.keys()
}

# select the smallest out of: maximum BGI application area OR parcel area 
area_cap = {
    (idx, bgi): min(gdf.at[idx, 'area m2'], bgi_max_area.get(bgi, float('inf')))
    for idx, row in gdf.iterrows()
    for bgi in row['suitable_bgis']
}

######################                                         OPTIMIZATION FUNCTION
def run_optimization(weights, max_budget=None):
    start_time = time.time()
    mfi_scores = ( weights['retention'] * retention_arr / median_retention +
               weights['temp'] * cooling_arr / median_cooling
             )
    mfi_dict = dict(zip(bgi_simple_impact.keys(), mfi_scores))

    prob = LpProblem("MFI_Optimization", LpMaximize)
    variables = {} 

    for idx, bgi in area_cap:
        var_name = f"x_{idx}_{bgi.replace(' ', '_')}"
        variables[(idx, bgi)] = LpVariable(var_name, cat='Binary')

    prob += lpSum(
        variables[(idx, bgi)] * mfi_dict[bgi] * area_cap[(idx, bgi)]
        for (idx, bgi) in variables)

    for idx in gdf.index:
        prob += lpSum(
            variables[(idx, bgi)] for bgi in gdf.at[idx, 'suitable_bgis']
            if (idx, bgi) in variables) <= 1

    if max_budget is not None: 
        prob += lpSum(
            variables[(idx, bgi)] * bgi_installation_cost.get(bgi, 0) * area_cap[(idx, bgi)]
            for (idx, bgi) in variables) <= max_budget

    prob.solve()
    runtime = time.time() - start_time
    print(f"status: {LpStatus[prob.status]} in {runtime:.1f} seconds")

    selected_vars = [
        (idx, bgi) for (idx, bgi), var in variables.items()
        if var.varValue == 1]

    gdf_result = gdf.copy()
    gdf_result['selected_bgi'] = None
    gdf_result['selected_bgi_area'] = 0.0

    for idx, bgi in selected_vars:
        gdf_result.at[idx, 'selected_bgi'] = bgi
        gdf_result.at[idx, 'selected_bgi_area'] = area_cap[(idx, bgi)]
    print(mfi_dict)
    return gdf_result

######################                                         SAVE RESULT FUNCTION 
def save_result(gdf_result, weights):
    retention_w = weights['retention']
    temp_w = weights['temp']
    filename = f"optimization_results_r{retention_w}_t{temp_w}.gpkg"
    layer = f"results_r{retention_w}_t{temp_w}"
    gdf_result.to_file(filename, layer=layer, driver='GPKG')
    print(f"Saved to {filename}, layer '{layer}'")

######################                                      WEIGHTS EXAMPLE STRUCTURE 
example1_weights = {'retention': 5, 'temp': 1}
example2_weights = {'retention': 1, 'temp': 5}

ex1_solution_df = run_optimization(example1_weights)
ex2_solution_df = run_optimization(example2_weights)

save_result(ex1_solution_df, {'retention': 5, 'temp': 1})
save_result(ex2_solution_df, {'retention': 1, 'temp': 5})

