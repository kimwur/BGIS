##### packages to import 
import geopandas as gpd
import pyogrio
import pandas as pd
import ast

##### for reading text per word instead of as string 
def safe_literal_eval(val):
    if isinstance(val, str):
        try:
            return ast.literal_eval(val)
        except Exception:
            return val
    return val

def load_bgi_database(filename):
    local_vars = {}
    with open(filename) as f:
        exec(f.read(), {}, local_vars)
    return local_vars

# load in BGI database 
BGI_CATALOG_FILE = 'example_bgi_database.txt'
catalog_data = load_bgi_database(BGI_CATALOG_FILE)
bgi_catalog = catalog_data['bgi_catalog']
slope_categories = catalog_data['slope_categories_max_degree']
maintenance_categories = catalog_data['maintenance_categories']

# loading in the shapefile 
# ENTER YOUR SHAPEFILE HERE
GPKG_FILE='shapefile.gpkg'
LAYER_NAME = 'feasibility'
gdf = gpd.read_file(GPKG_FILE, layer=LAYER_NAME, engine='pyogrio')

# mapping dictionaries so landcover input matches BGI catalog
land_slopes_dictionary = { 'nearly level': 1,
                           'very gentle slope': 2.5, 
                           'gentle slope': 5, 
                           'moderate slope': 10, 
                           'strong slope': 15,
                           'very strong slope': 20,
                           'steep slope': 30,
                           'very steep slope': 45,  
                           'extreme slope': 90}

gdf['slope degree'] = gdf['slope'].map(land_slopes_dictionary)


landcover_dictionary = { 
    'other': 'none',
    'flat roof': 'roof',
    'water': 'none',
    'building': 'building',
    'steep roof': 'none',
    'road': 'pavement',
    'parking': 'pavement',
    'paved area': 'pavement',
    'half-paved area': 'ground',
    'unpaved area': 'ground',
    'greenery': 'ground',
    'grass': 'ground',
    'forest': 'none'
}

gdf['basic_lulc'] = gdf['landcover'].map(landcover_dictionary)

# feasibility check

def feasibility(land_data_file):
    suitable_bgis = [[] for _ in range(len(land_data_file))]

    cell_lulc = land_data_file['basic_lulc']
    cell_slope = land_data_file['slope degree'].copy()
    cell_area = land_data_file['area']
    cell_slope[cell_lulc == 'roof'] = land_slopes_dictionary['nearly level']

    for bgi_name, bgi in bgi_catalog.items():
        mask_lulc = cell_lulc.isin(bgi['lulc'])
        slope_cat = bgi.get('slope_cat')[0]
        max_bgi_slope_degree = slope_categories.get(slope_cat, float('inf'))
        mask_slope = cell_slope <= max_bgi_slope_degree
        min_bgi_area = bgi['area_m2'].get('min', 0)
        mask_area = (cell_area >= min_bgi_area)

        mask = mask_lulc & mask_slope & mask_area

        for idx in mask[mask].index:
            suitable_bgis[idx].append(bgi_name)

    land_data_file['suitable_bgis'] = suitable_bgis
    return land_data_file

# run function
feasibility_gdf = feasibility(gdf)

# add binary matrix
bgi_binary = pd.DataFrame(0, index=feasibility_gdf.index, columns = list(bgi_catalog.keys()))
for idx, bgis in enumerate(feasibility_gdf['suitable_bgis']):
    bgi_binary.loc[idx, bgis] = 1

feasibility_gdf = pd.concat([feasibility_gdf, bgi_binary], axis=1)

# save file
feasibility_gdf.to_file("feasibility_results.gpkg", layer="feasibility", driver="GPKG")
